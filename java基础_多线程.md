# 进程和线程
>一个进程中有多个线程，叫多线程
1. 区别
    - 一个进程至少有一个线程
    - 进程在执行过程中拥有独立的内存单元，而多个线程共享内存
2. 多线程的优势
    - 解决了多部分同时运行的问题，提高效率
3. 多线程弊端
    - 线程太多会导致效率的降低，因为线程的执行依靠cpu的来回切换

# 多线程的实现方法
1. 继承Thread类
2. 实现Runnable接口，推荐使用该方式

# run() 和 start()区别
>调用start()方法可以启动线程，run()不可以
1. start()方法：
    - 启动线程，实现多线程的运行，无需等待run方法体代码执行完毕而直接继续下面的代码
    - 通过调用Thread类的start()方法来启动一个线程，这时线程处于就绪（可运行）状态，并没有运行
    - 当该线程得到cpu时间片，就开始执行run()方法，这里方法run()称为线程体

# 线程的状态
1. 新建，new 一个Thread对象，线程创建但未开启，此时，只是对象线程开辟内存空间和初始化数据
2. 就绪，调用 start()方法，开启线程，线程进入就绪状态
3. 运行，当线程对象获取到cpu资源
4. 冻结，运行过程中的线程由于某些原因(wait,sleep),释放了执行资格和执行权
5. 死亡，线程对象调用run方法结束，或者直接调用stop方法

# sleep() ，wait()， notify(), notifyAll() 
1. sleep()来自Thread类，wait()来自Object类
2. sleep()是Thread的静态类方法，谁调用谁去谁去睡觉（a线程调用b的sleep方法，实际上还是a去睡觉）。wait()是Object类的非静态方法
3. sleep()释放资源不释放锁，wait() 释放资源释放锁
4. wait(), notify,notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用
5. notify() 唤醒一个处于等待状态的线程，由JVM确定唤醒哪个线程，不是按照优先级
6. notifyAll() 唤醒所有处于等待状态的线程，线程竞争上岗

# 锁
1. 锁的作用是保证线程同步，解决线程安全问题
2. 持有锁的线程可以在同步中执行，没有锁的线程即使获得cpu执行权也进不去

# 同步
1. 利： 解决多线程安全问题
2. 弊： 需要判断锁，比较消耗资源
3. 同步的两种表现方式：
    - 同步代码块
    - 同步函数

# 死锁
两个线程对两个同步对象具有循环依赖时，就会发生死锁。即同步嵌套同步，而锁却不同

# wait() ,notify(), notifyAll() 操作线程的方法定义在Object类中
1. 这些方法只存在于同步中
2. 使用这些方法时必须要指定所属的锁，即被哪个锁调用这些方法；
3. 而锁可以是任意对象，所以任意对象调用的方法就定义在Object中。

# 线程间通信
>多线程间通讯就是多个线程操作同一个资源，但是操作的动作不同
1. 为什么
    - 多线程并发执行的时候，如果需要指定线程等待或者唤醒指定线程，需要通信
2. 怎么做
    - 在同步代码块中，使用锁对象的wait()方法可以让当前线程等待，直到有其他线程唤醒位置
    - 使用锁对象的notify()方法可以唤醒一个等待的线程，或者使用nofityAll()唤醒所有等待的线程
    - 不可以用sleep(),因为睡眠时间很难把握

# Lock 和 Condition
>实现比synchronized方法和语句可获得更广泛的锁的操作，可以支持多个相关的Condition对象

1. Lock是个接口
    - 锁是控制多个线程对共享数据进行访问的工具
    - JDK1.5 之后，synchronized 替换成显示的Lock操作，将Object中的wait(), notify(), notifyAll()替换成Condition对象，该对象可以对Lock进行获取
2. Lock方法摘要
    - void lock(), 获取锁
    - Condition newCondition() 返回绑定到此Lock实例的新Condition对象
    - void unlock(), 释放锁
3. Condition 方法摘要
    - void await(), 等待状态
    - void signal(), 唤醒一个线程
    - void signalAll() 唤醒所有等待线程

