1. 面向对象
	三个特征： 封装，继承，多态
2. 多态优点
	可替换： 对已存在代码具有可替换性
	可扩充： 增加新的子类，不影响已经存在的类结构
3. 多态实现
	接口实现，继承父类重写方法，同一类中进行方法重载
4. 虚拟机是如何实现多态
	动态绑定技术，执行期间判断所引用对象的实际类型，根据实际类型调用对应的方法
5. 接口的意义
	规范。扩展。回调
6. 抽象类的意义
	- 为其他子类提供一个公共类型
	- 封装子类中重复定义的内容

7. 父类的静态方法不可以被子类重写。

8. 什么是不可变对象
	一旦被创建，状态不能改变，任何修改都会创建一个新的对象，如String,Integer等包装类

9. 静态变量和实例变量区别
	静态的存储在方法区，属于类所有。
	实例的存在堆当中，其引用存在当前线程栈

10. Java创建对象的方式
	new
	反射
	clone
	序列化机制

11. switch,只支持byte,short,char, int及其对应的封装类enum,jdk7 之后支持String

12. String s1=”ab”, String s2=”a”+”b”, String s3=”a”, String s4=”b”, s5=s3+s4请问s5==s2返回什么？
	返回false。在编译过程中，编译器会将s2直接优化为”ab”，会将其放置在常量池当中，s5则是被创建在堆区，相当于s5=new String(“ab”);

13. String对象的intern()
	该方法会从常量池中查找是否存在该值，不存在直接创建，存在直接返回
	String s1=”aa”; 
	String s2=s1.intern(); 
	System.out.print(s1==s2);//返回true

14. Object中的公共方法
	equals()
	clone()
	getClass()
	notify(),notifyAll(), wait()
	toString

15. java当中的四种引用，不同的引用类型主要体现GC上
	强引用，若某个对象有强引用，该对象不会被回收；通过对象引用赋值 null,可取消强引用
	软引用，只有在内存空间不足的时候才会被回收
	弱引用，回收器一旦发现该引用，就回收
	虚引用，任何时候都可以被回收

16. 为何需要不同的引用类型
	主要是对GC回收不可控的妥协
	使用场景
		- 利用软引用和弱引用解决OOM问题，用一个HashMap来保存图片的路径和相应图片对象关联	的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空	间，从而有效地避免了OOM的问题；
		- 通过软引用是新啊Java对象的高速缓存：比如我们创建了一Person的类，如果每次需要查	询一个人的信息,哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大	量Person对象的消耗，并且由于这些对象的生命周期相对较短，会引起多次GC影响性能。	 此时，通过软引用和 HashMap 的结合可以构建高速缓存，提供性能。

17. == 和 equals()区别
	== 用于比较两个变量是否相等，常用于基本类型比较；
	equals() 默认用于比较两个对象是否相等，此时和 == 结果一样；
	默认下，对象用 == 比较时，比较的是内存地址，

18. equals() hashcode() 关系
	hashcode()是 Object类的方法，返回一个哈希值。若两个对象相等，则其哈希值相等；若不相等，那么产生的哈希值不一定相等（碰撞的情况下还是会相等的），即两个不相等的对象可能会有相同的hashcode值，这就是为什么hashmap中会有冲突

19. 3*0.1==0.3返回false, 因为有些浮点数不能精确的表示出来

20. a=a+b, a+=b 区别
	+= 操作符会进行隐式自动类型转换，
	byte a = 127; 
	byte b = 127; 
	b = a + b; // error : cannot convert from int to byte 
	b += a; // ok 
	（ a + b操作会将 a,b 提升为int 类型，所以将int类型赋值给byte 就会报编译出错）

21. & 和 &&区别
	＆　位操作，
	＆＆　逻辑运算符，具有短路特性

22. 一个Java文件内部是否可以有非内部类
	只能有一个public公共类，但是可以有多个default修饰的类

23. 如何正确的退出多层嵌套循环
	- 使用标号和 break
	- 通过在外层循环中添加标识符

24. 内部类作用
	- 封装性更好，除了该外围类，其余类都不能访问
	- 可以有多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立
	- 单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类
	- 内部类的创建不依赖外部对象的创建
	- 没有 is-a关系，就像是一个独立的实体


26. 深拷贝 / 浅拷贝 区别
	浅拷贝： 仅复制所考虑对象，不复制引用对象，被复制对象的所有变量都含有与原来的对象相			同的值，而所有的对其他对象的引用仍然指向原来的对象
	深拷贝： 被复制对象所引用对象也复制一遍，被复制对象的所有变量都含有与原来的对象相同			的值，而那些引用其他对象的变量将指向被复制过的新对象


