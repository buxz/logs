# 数据类型
1. 基本数据类型（4类8种）
	- 整数类型： byte, short, int, long
	- 浮点型：float, double
	- 字符类型： char
	- 布尔类型： boolean
2. 引用数据类型
	- 类
	- 接口
	- 数组

# switch语句
只支持byte,short,char, int及其对应的封装类enum,jdk7 之后支持String

# 实例代码

>== 使用

```
# 返回false。在编译过程中，编译器会将s2直接优化为”ab”，会将其放置在常量池当中，s5则是被创建在堆区，相当于s5=new String(“ab”);
 String s2 = "a" +"b";
 String s3 = "a";
 String s4 = "b";
 String s5 = s3 + s4;
 System.out.println(s5 == s2);
```

>数据运算,返回false, 因为有些浮点数不能精确的表示出来

```
3*0.1==0.3
```

# String 对象的intern()
```
	# 该方法会从常量池中查找是否存在该值，不存在直接创建，存在直接返回
	String s1=”aa”; 
	String s2=s1.intern(); 
	System.out.print(s1==s2);//返回true
```

# Object中的公共方法
1. equals()
2. getClass()
3. notify(),notifyAll(), wait()
4. toString

# 四种引用
1. 不同的引用类型主要体现GC上
	- 强引用，若某个对象有强引用，该对象不会被回收；通过对象引用赋值 null,可取消强引用
	- 软引用，只有在内存空间不足的时候才会被回收
	- 弱引用，回收器一旦发现该引用，就回收
	- 虚引用，任何时候都可以被回收
2. 使用场景
	- 利用软引用和弱引用解决OOM问题：用一个HashMap来保存图片的路径和相应图片对象关联	的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空	间，从而有效地避免了OOM的问题；
	- 通过软引用实现Java对象的高速缓存：比如我们创建了一Person的类，如果每次需要查	询一个人的信息,哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大	量Person对象的消耗，并且由于这些对象的生命周期相对较短，会引起多次GC影响性能。	 此时，通过软引用和 HashMap 的结合可以构建高速缓存，提供性能。

# a=a+b, a+=b 区别
1. += 操作符会进行隐式自动类型转换，
2.  a + b操作会将 a,b 提升为int 类型，所以将int类型赋值给byte 就会报编译出错）
```
	byte a = 127; 
	byte b = 127; 
	b = a + b; // error : cannot convert from int to byte 
	b += a; // ok 
```

# & 和 &&区别
1. ＆　位操作，
2. ＆＆　逻辑运算符，具有短路特性

# 深拷贝 / 浅拷贝 区别
1. 浅拷贝:
	- 仅复制所考虑对象，不复制引用对象，
	- 被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象
2. 深拷贝:
	- 被复制对象所引用对象也复制一遍
	- 被复制对象的所有变量都含有与原来的对象相同的值，而那些引用其他对象的变量将指向被复制过的新对象		







