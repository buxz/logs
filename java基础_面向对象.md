# 面向对象特征
1. 封装
    - 隐藏对象的属性和实现细节，仅对外提供访问方式
    - 提高复用性，安全性，方便使用，隔离变化
2. 继承
    - 多个类存在相同属性和行为时，将这些内容抽取到某单一类中，继承该类即可
    - 只能单继承不可多继承，允许多层继承
3. 多态
    - 一个对象在程序不同运行时刻代表的多种状态，父类或者接口的引用指向子类对象
    - 好处，提高程序的扩展性和后期可维护性，
    - 弊端，只能访问父类中已有的功能，运行的是后期子类的功能内容
    - 实现方式：接口实现；继承父类重写方法；同一类中进行方法重载
    - JVM通过动态绑定技术实现多态，执行期间判断所引用对象的实际类型，根据实际类型调用对应的方法

# 成员变量和局部变量区别

区别|成员变量|局部变量
---|---|---
作用域 | 针对整个类| 只在某个范围内有效（方法，语句体）
存储位置|存储在堆内存中，随着对象创建/消失| 存储在栈内存中，随着方法/语句体而存在
初始值| 有默认初始值| 无默认初始值，使用前必须赋值


# 静态变量与成员变量的区别

区别|成员变量（实例变量）|静态变量（类变量）
---|---|---
调用方式 | 所属于对象，只能通过对象名调用 | 直接通过类名调用，也可以通过对象名调用
存储位置|堆内存|方法区中的静态区
生命周期| 跟随对象 |跟随类，生命周期长
与对象的相关性| 每个对象所特有 | 所有对象共享

# 构造方法
>用户创建对象，并对其进行初始化赋值，对象一建立就自动调用相对应的构造函数
1. 注意事项：
    - 系统默认无参构造方法
    - 自定义构造方法时，需要手动给出无参构造
2. 与成员方法的区别

# 构造代码块
>用于对象初始化，对象一旦建立就执行，而且优于构造函数执行

1. 构造函数与构造代码块区别
    - 构造代码块是给所有不同对象的共性进行统一初始化
    - 构造函数是给对应对象进行初始化
2. 静态代码块
    - 只执行一次，且比main函数优先
    - 执行顺序 ： 静态代码块 -- 构造代码块 -- 构造方法
    
# 关键字
1. this 
2. static
    - 用来修饰成员变量和成员函数
    - 随着类的加载而加载，静态内容先进内存，故静态方法只可以访问静态成员
    - 优先于对象存在
    - 对所有对象共享
    - 可以被类名直接调用
    - 父类的静态方法不可以被子类重写
3. final
    - 修饰类，方法，变量
    - 修饰的类不可以被继承，修饰的方法不可被重写，修饰的变量不能被修改
    - 内部类，只能访问被final修饰的局部变量
4. instanceof
    - 判断某个对象是否是某种类型
5. package
    - 

# 对象创建
1. 下列代码在内存中做了哪些事情
```
Person p = new Person();
```

- 将Person.class 文件加载进内存中
- 如果P 定义在主方法中，那么在栈空间开辟一个变量空间 p
- 在堆内存中给对象分配空间
- 对对象中的成员进行默认初始化
- 对对象中的成员进行显示初始化
- 调用构造代码块对对象进行初始化
- 调用构造方法对对象进行初始化
- 将对象的内存地址赋值给p变量，让p指向该对象

# 重写与重载区别
1. 重载：
    - 在同一个类中，方法名相同，参数列表不同。可以改变返回类型
2. 重写：
    - 在不同类（子父类）中，方法签名相同（返回类型，方法名，参数列表）
    - 子类方法的访问权限要大于等于父类方法的访问权限

# 抽象类
1. 包含抽象方法的类是抽象类
2. 抽象类不可被实例化
3. 抽象类中不一定有抽象方法，但是有抽象方法的类一定是抽象类
4. 抽象类有构造方法，供子类实例化调用
5. abstract 与 private/final/static冲突

# 接口interface
1. 成员变量都是常量，默认修饰 public static final
2. 成员方法都是抽象的，默认修饰 public abstract
3. 一个类可以实现多个接口，接口之间可以继承
4. 特点：
    - 对外暴露
    - 功能扩展
    - 降低耦合
5.与抽象类区别
    - 抽象类不可多继承，接口可以多实现
    - 抽象类中定义继承体系的共性功能，接口定义继承体系的扩展功能

# == 和 equals()区别
1. 基本数据类型，变量直接存储的是‘值’
2. 非基本数据类型（引用类型），变量存储的是对象在内存中的地址
3. == 用于比较基本类型，比较的值；比较引用类型，比较的是对象的内存地址
4. equals，是基本Object中的方法，看源码发现默认是比较的内存地址，其他类比如String类是重写的该方法，所以比较的不仅是内存地址，还比较的是值
5. equals 方法不能作用于基本数据类型的变量 
```
String str = new String("hello");
String str1 = new String("hello");
String str2 = new String("hello");
System.out.println(str1==str2); // false，比较的是地址
System.out.println(str1.equals(str2)); // true, String类重写的equals方法，不仅比较内存地址，还比较内容

str1 = str;
str2 = str;
System.out.println(str1==str2); // true,比较的是内存地址

int n=3;
int m=3;
System.out.println(n==m);// true,基本数据类型，直接比较值
```

# equals() hashcode() 关系
1. hashcode()是 Object类的方法，返回一个哈希值
2. 若两个对象相等，则其哈希值相等
3. 若不相等，那么产生的哈希值不一定相等（碰撞的情况下还是会相等的），即两个不相等的对象可能会有相同的hashcode值，这就是为什么hashmap中会有冲突

# 内部类
>把一个类定义在某个类中，又称内置类，嵌套类
1. 访问特点
    - 可以直接外部类成员，因为内部类持有外部类的引用
    - 外部类要想访问内部类的成员，必须创建对象访问
2. 使用场景
    - 假如有A类和B类，A类想直接访问B类的成员，且B类访问A类成员的时候，
        需要创建A类对象进行访问，这个时候，就可以把A类定义为B类的内部类。
3. 作用
    - 封装性更好，除了该外围类，其余类都不能访问
    - 可以有多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立
    - 单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类
    - 内部类的创建不依赖外部对象的创建
    - 没有 is-a关系，就像是一个独立的实体

# 匿名内部类
>仅为简化书写，且有局限性，通常定义匿名内部类时，该类方法不超过3个
1. 前提：
    - 继承一个类或者实现一个接口
2. 弊端：
    - 不能直接调用自己的特有方法
    - 不能执行强转换动作
    - 若该类里面方法较多，不允许使用匿名内部类

# final,finalize, finally 区别
- final,修饰符，修饰变量，方法，类；若修饰变量，则该变量在初始化后不可变
- finalize, 对象被回收之前调用的方法
- finally, 关键字，与try catch一起用于异常的处理，无论是否有异常，finally块一定会被执行 

# 内存结构
1. 堆内存
    - 数组和对象，通过new建立的实例都存放在堆内存中。
2. 栈内存
    - 用于存储局部变量，当数据使用完毕，所占空间会自动释放
3. 方法区
    - 静态成员、构造函数、常量池、线程池
4. 本地方法区
    - window系统占用
5. 寄存器

# 不可变对象
>一旦被创建，状态不能改变，任何修改都会创建一个新的对象，如String,Integer等包装类

# java 创建对象的方式
1. new
2. 反射
3. clone
4. 序列化机制
